import html
import os
import re
from pathlib import Path

import pandas as pd
import streamlit as st

from duckdb_client import get_duckdb_client


DEFAULT_DB_NAME = os.environ.get("DUCKDB_DATABASE", "database.duckdb")
DEFAULT_TABLE = os.environ.get("DUCKDB_TABLE", "costs")


def get_db_path(db_name: str) -> Path:
    return Path(__file__).resolve().parent.parent / "db" / db_name


@st.cache_data(show_spinner=False)
def load_data(db_name: str, table_name: str):
    client = get_duckdb_client(db_name)
    return client.get_services_metrics(table_name)


def safe_div(numerator, denominator):
    if denominator in (0, None) or pd.isna(denominator):
        return pd.NA
    return numerator / denominator


def build_total_series(df: pd.DataFrame, metric_cols: list[str]) -> pd.Series:
    sums = {}
    for col in metric_cols:
        if pd.api.types.is_numeric_dtype(df[col]):
            sums[col] = df[col].sum()

    totals = {metric: sums.get(metric, pd.NA) for metric in metric_cols}

    if "delta_day" in metric_cols and {"cost", "prev_day"} <= sums.keys():
        totals["delta_day"] = sums["cost"] - sums["prev_day"]
    if "delta_week" in metric_cols and {"cost", "prev_week"} <= sums.keys():
        totals["delta_week"] = sums["cost"] - sums["prev_week"]
    if "delta_7d" in metric_cols and {"cost", "avg7"} <= sums.keys():
        totals["delta_7d"] = sums["cost"] - sums["avg7"]
    if "delta_30d" in metric_cols and {"cost", "avg30"} <= sums.keys():
        totals["delta_30d"] = sums["cost"] - sums["avg30"]
    if "delta_prev" in metric_cols and {"mtd", "prev_mtd"} <= sums.keys():
        totals["delta_prev"] = sums["mtd"] - sums["prev_mtd"]
    if "delta_prev2" in metric_cols and {"mtd", "prev2_mtd"} <= sums.keys():
        totals["delta_prev2"] = sums["mtd"] - sums["prev2_mtd"]
    if "delta_prev3" in metric_cols and {"mtd", "prev3_mtd"} <= sums.keys():
        totals["delta_prev3"] = sums["mtd"] - sums["prev3_mtd"]
    if "delta_avg6" in metric_cols and {"mtd", "avg6"} <= sums.keys():
        totals["delta_avg6"] = sums["mtd"] - sums["avg6"]
    if "delta_avg12" in metric_cols and {"mtd", "avg12"} <= sums.keys():
        totals["delta_avg12"] = sums["mtd"] - sums["avg12"]

    if "pct_7d" in metric_cols and {"cost", "avg7"} <= sums.keys():
        totals["pct_7d"] = safe_div(sums["cost"] - sums["avg7"], sums["avg7"])
    if "pct_week" in metric_cols and {"cost", "prev_week"} <= sums.keys():
        totals["pct_week"] = safe_div(
            sums["cost"] - sums["prev_week"], sums["prev_week"]
        )
    if "pct_prev" in metric_cols and {"mtd", "prev_mtd"} <= sums.keys():
        totals["pct_prev"] = safe_div(sums["mtd"] - sums["prev_mtd"], sums["prev_mtd"])
    if "pct_prev2" in metric_cols and {"mtd", "prev2_mtd"} <= sums.keys():
        totals["pct_prev2"] = safe_div(
            sums["mtd"] - sums["prev2_mtd"], sums["prev2_mtd"]
        )
    if "pct_prev3" in metric_cols and {"mtd", "prev3_mtd"} <= sums.keys():
        totals["pct_prev3"] = safe_div(
            sums["mtd"] - sums["prev3_mtd"], sums["prev3_mtd"]
        )
    if "pct_avg6" in metric_cols and {"mtd", "avg6"} <= sums.keys():
        totals["pct_avg6"] = safe_div(sums["mtd"] - sums["avg6"], sums["avg6"])
    if "pct_avg12" in metric_cols and {"mtd", "avg12"} <= sums.keys():
        totals["pct_avg12"] = safe_div(sums["mtd"] - sums["avg12"], sums["avg12"])

    return pd.Series(totals)


def main() -> None:
    st.set_page_config(page_title="AWS Costs Dashboard", layout="wide")
    st.title("AWS Costs Dashboard")

    db_name = st.sidebar.text_input("DuckDB file", DEFAULT_DB_NAME)
    table_name = st.sidebar.text_input("Table name", DEFAULT_TABLE)

    if not re.match(r"^[A-Za-z_][A-Za-z0-9_]*$", table_name):
        st.error("Table name non valido.")
        return

    db_path = get_db_path(db_name)
    if not db_path.exists():
        st.error(f"File DuckDB non trovato: {db_path}")
        return

    df = load_data(db_name, table_name)
    if df.empty:
        st.info("Nessun dato disponibile per la query.")
        return

    if "date" in df.columns:
        df["date"] = pd.to_datetime(df["date"], errors="coerce").dt.date

    accounts = sorted(df["account"].dropna().unique().tolist())
    services = sorted(df["service"].dropna().unique().tolist())

    account_filter = st.sidebar.multiselect("Account", accounts, default=accounts)
    service_filter = st.sidebar.multiselect("Service", services, default=services)

    filtered = df[
        df["account"].isin(account_filter) & df["service"].isin(service_filter)
    ]

    st.markdown(
        """
        <style>
        .table-wrap {
            overflow-x: auto;
            max-width: 100%;
        }
        table.costs-table {
            border-collapse: separate;
            border-spacing: 0;
            width: max-content;
            min-width: 100%;
        }
        table.costs-table th,
        table.costs-table td {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(200, 200, 200, 0.15);
            color: #c7c7c7;
            vertical-align: top;
            white-space: nowrap;
        }
        table.costs-table th {
            font-weight: 600;
            background: rgba(0, 0, 0, 0.12);
        }
        table.costs-table td .cell {
            white-space: normal;
            line-height: 1.15;
        }
        table.costs-table td .main {
            font-size: 14px;
            color: #c7c7c7;
        }
        table.costs-table td .sub {
            font-size: 11px;
            color: #9aa0a6;
            margin-top: 2px;
        }
        table.costs-table th.metric-col,
        table.costs-table td.metric-col {
            position: sticky;
            left: 0;
            z-index: 3;
            background: rgba(17, 17, 17, 0.95);
            min-width: 180px;
        }
        table.costs-table th.total-col,
        table.costs-table td.total-col {
            position: sticky;
            left: 180px;
            z-index: 2;
            background: rgba(17, 17, 17, 0.95);
            min-width: 140px;
        }
        </style>
        """,
        unsafe_allow_html=True,
    )

    metric_cols = [
        col for col in filtered.columns if col not in {"date", "account", "service"}
    ]
    if not metric_cols:
        st.info("Nessuna metrica disponibile.")
        return

    row_defs = [
        ("mtd", None, None),
        ("prev_mtd", "delta_prev", "pct_prev"),
        ("prev2_mtd", "delta_prev2", "pct_prev2"),
        ("prev3_mtd", "delta_prev3", "pct_prev3"),
        ("avg6", "delta_avg6", "pct_avg6"),
        ("avg12", "delta_avg12", "pct_avg12"),
    ]

    row_labels = {
        "mtd": "Mese corrente",
        "prev_mtd": "Mese precedente",
        "prev2_mtd": "2 mesi fa",
        "prev3_mtd": "3 mesi fa",
        "avg6": "Media 6M",
        "avg12": "Media 12M",
    }

    def format_cell(value, delta, pct):
        if pd.isna(value):
            return ""
        main = f"{value:.2f}"
        if delta is None and pct is None:
            return f'<div class="cell"><div class="main">{main}</div></div>'
        delta_str = "" if pd.isna(delta) else f"{delta:+.2f}"
        pct_str = "" if pd.isna(pct) else f"{pct * 100:+.1f}%"
        return (
            '<div class="cell">'
            f'<div class="main">{main}</div>'
            f'<div class="sub">Î” {delta_str} ({pct_str})</div>'
            "</div>"
        )

    for account in account_filter:
        account_df = filtered[filtered["account"] == account]
        if account_df.empty:
            continue

        st.markdown(f"**Account:** {account} (in USD)")

        services = sorted(account_df["service"].dropna().unique().tolist())
        service_rows = account_df.set_index("service")
        if service_rows.index.has_duplicates:
            service_rows = service_rows.groupby(level=0).first()

        totals = build_total_series(account_df, metric_cols)

        header_cells = [
            '<th class="metric-col">Metric (MTD)</th>',
            '<th class="total-col">Total</th>',
        ] + [f"<th>{html.escape(service)}</th>" for service in services]
        header_row = f"<tr>{''.join(header_cells)}</tr>"

        body_rows = []
        for metric, delta_col, pct_col in row_defs:
            label = html.escape(row_labels.get(metric, metric))
            total_cell = format_cell(
                totals.get(metric), totals.get(delta_col), totals.get(pct_col)
            )
            row_cells = [
                f'<th class="metric-col">{label}</th>',
                f'<td class="total-col">{total_cell}</td>',
            ]
            for service in services:
                if service not in service_rows.index:
                    cell = ""
                else:
                    row = service_rows.loc[service]
                    cell = format_cell(
                        row.get(metric), row.get(delta_col), row.get(pct_col)
                    )
                row_cells.append(f"<td>{cell}</td>")
            body_rows.append(f"<tr>{''.join(row_cells)}</tr>")

        table_html = (
            '<div class="table-wrap">'
            '<table class="costs-table">'
            f"<thead>{header_row}</thead>"
            f"<tbody>{''.join(body_rows)}</tbody>"
            "</table>"
            "</div>"
        )
        st.markdown(table_html, unsafe_allow_html=True)


if __name__ == "__main__":
    main()
